<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>OH FINE</title>
  <meta name="description" content="this is inelegant and demeaning but if it works I suppose I'll have to live with it.">
  <meta name="author" content="SitePoint">

  <meta property="og:title" content="OH FINE>
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://emdashbuck.github.io/capitulation-euler">
  <meta property="og:description" content="this is inelegant and demeaning but if it works I suppose I'll have to live with it.">
</head>

<body>
  <h1>IGUESS.gif</h1>
  <p id="test"></p>

  <h2>Euler 3</h2>
  <p>The prime factors of 13195 are 5, 7, 13 and 29.</p>
  <p>What is the largest prime factor of the number 600851475143 ?</p>
  <p id="e3answer"></p>
  
  <h2>Euler 2</h2>
  <p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p>
  <p class="center">1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p>
  <p>The sum of the even terms in this set is 44.</p>
  <p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
  <p id="answer2"></p>

  <h2>Euler 1</h2>
  <p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p>
  <p>Find the sum of all the multiples of 3 or 5 below 1000.</p>
  <p id="answer1"></p>
<script>
//============================ Useful bits

//Sequence generator from Mozilla JS docs
const natNumRange = (start, stop, step) => Array.from({ length: (stop - start) / step + 1}, (_, i) => start + (i * step));

const natNum1999 = natNumRange(1,999,1);
const natNum19 = [1,2,3,4,5,6,7,8,9];
const natNum29 = [2,3,4,5,6,7,8,9];
</script>
<script id="e3">
//============================     3     ============================

//==============      3.1: Create list of primes

//========      3.1.1: Construct a wheel
//A wheel tells you which numbers to automatically skip. The simplest wheel skips every other number starting from 4, thus omitting multiples of 2.

//After some laborious manual calculations, have confirmed that this one should work, at least good enough for now - a repeating pattern to accrue a list of numbers not divisible by 2,3,5, or 7.
//2,4,2,4,6,2,6,4,2,4,6,6,2,6,4,2,6,4,6,8,4,2,4,2,4,8,6,4,6,2,4,6,2,6,6,4,2,4,6,2,6,4,2,4,2,10,2,10

//The paper I was reading was also suggesting a sort of lazy wheel: one spot for each prime. As a number comes up for evaluation, if it's in the list, replace list item with the number + product(eg 2*3*5*7) and discard as combinatorial.

function e3_1wheelrun(upto) {
  spins = upto / 210 //2*3*5*7
  while (i < spins) {
    
   i ++;
  }
}


//number we want to get prime divisors for
const e3number = 10








//ðŸ§¶ lines copied from https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes

//ðŸ§¶ To find all the prime numbers less than or equal to a given integer n by Eratosthenes' method:

//ðŸ§¶ 1. Create a list of consecutive integers from 2 through n: (2, 3, 4, ..., n).
//We have to do a series of lists due to the Array length limit.

const e3OddRange = natNumRange(31,e3number,2);
const e3addlowprimestofront = [2,3,5,7,11,13,17,19,23,29,e3OddRange];
const e3range = e3addlowprimestofront.flat(2);
//using an outside var, process took 24sec. Carrying primesList back and forth to avoid using var added 10sec lol
var primesList = []; //NOT functional but at least it's only ever changed by the function createPrimesList :(
//var runCounter = 0;
const e3primesList = e3createPrimesList(e3range,Array());

//ðŸ§¶ 2. Initially, let p equal 2, the smallest prime number.
//ðŸ§¶ 4. Find the smallest number in the list greater than p that is not marked. If there was no such number, stop. Otherwise, let p now equal this new number (which is the next prime), and repeat from step 3.
function e3createPrimesList (potentialPrimes) { 
  //begin with the quit condition. We're removing nonprimes instead of marking them, so if the list is empty we're done
//runCounter ++;
if (potentialPrimes.length == 0) { //console.log("e3createPrimesList ran ",runCounter," times.");
return primesList }
else {
  let p = potentialPrimes.shift();
  primesList.push(p); //No marked numbers, so first item will always be the next prime
  return e3pIncrementCount(potentialPrimes, p);
  };
}

//ðŸ§¶ 3. Enumerate the multiples of p by counting in increments of p from 2p to n, and mark them in the list (these will be 2p, 3p, 4p, ...; the p itself should not be marked).
function e3pIncrementCount (potentialPrimes, p) {
  let countArr = e3range.map(val => val * p); //returns a list of multiples of p
  let newpotentialPrimes = potentialPrimes.filter((val) => { return (countArr.includes(val) ? false : true) }); //marked in list by removing them from the list
  return e3createPrimesList(newpotentialPrimes); //pass it back to see if we're done
}


// **** With list of primes smaller than our number in hand, we can now determine which are its divisors. ****

const e3primeDivs = e3primesList.filter((val) => e3number % val == 0);

const e3answer = e3primeDivs.join();

document.getElementById("e3answer").innerHTML = e3answer;

</script>




















<script id="e2">

//============================      2     ============================


const stopValue2 = 4000000;
const fib2 = fibSeq2([1,2]);
const evenFib2 = fib2.filter((val,ind,arr) => { return val % 2 == 0; });
const answer2 = evenFib2.reduce((acc,cur) => { return acc + cur; },0);

document.getElementById("answer2").innerHTML = answer2;

//Ok to use mutable var as long as it remains inside the code block (no side effects).

function fibSeq2(CurrentArray) {
  if (CurrentArray[CurrentArray.length -1] < stopValue2) {
    return updatefibSeq2(CurrentArray);
  } else { CurrentArray.pop(); return CurrentArray; };
};

function updatefibSeq2 (UpdateMe){ 
    let NewArray = UpdateMe;
    NewArray.push((UpdateMe[UpdateMe.length - 1] + UpdateMe[UpdateMe.length - 2]));
    return fibSeq2(NewArray);
};
</script>
<script>

//============================      1     ============================

const filteredRange1 = natNum1999.filter((a) => { 
  return a % 3 == 0 || a % 5 == 0;
});

//accumulator and current
const answer1 = filteredRange1.reduce((acc, cur) => {
  return acc + cur;
//readonly = false
}, 0);

document.getElementById("answer1").innerHTML = answer1;



</script>
</body>
</html>
