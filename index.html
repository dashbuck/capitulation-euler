<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>OH FINE</title>
  <meta name="description" content="this is inelegant and demeaning but if it works I suppose I'll have to live with it.">
  <meta name="author" content="SitePoint">

  <meta property="og:title" content="OH FINE>
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://emdashbuck.github.io/capitulation-euler">
  <meta property="og:description" content="this is inelegant and demeaning but if it works I suppose I'll have to live with it.">
</head>

<body>
  <h1>IGUESS.gif</h1>
  <p id="test"></p>

  <h2>Euler 3</h2>
  <p>The prime factors of 13195 are 5, 7, 13 and 29.</p>
  <p>What is the largest prime factor of the number 600851475143 ?</p>
  <p id="e3answer"></p>

  <h2>Euler 2</h2>
  <p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p>
  <p class="center">1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p>
  <p>The sum of the even terms in this set is 44.</p>
  <p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
  <p id="answer2"></p>

  <h2>Euler 1</h2>
  <p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p>
  <p>Find the sum of all the multiples of 3 or 5 below 1000.</p>
  <p id="answer1"></p>
<script>
//============================ Useful bits

//Sequence generator from Mozilla JS docs
const natNumRange = (start, stop, step) => Array.from({ length: (stop - start) / step + 1}, (_, i) => start + (i * step));

const natNum1999 = natNumRange(1,999,1);
const natNum19 = [1,2,3,4,5,6,7,8,9];
const natNum29 = [2,3,4,5,6,7,8,9];

//============================      3     ============================

//Is it reasonable to create a list of primes?
//ðŸ§¶ lines copied from https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes

//ðŸ§¶ To find all the prime numbers less than or equal to a given integer n by Eratosthenes' method:

//ðŸ§¶ 1. Create a list of consecutive integers from 2 through n: (2, 3, 4, ..., n).
const e3range = natNumRange(2,99,1);
const e3answer = e3createPrimeList(e3range); 

//ðŸ§¶ 2. Initially, let p equal 2, the smallest prime number.
//ðŸ§¶ 4. Find the smallest number in the list greater than p that is not marked. If there was no such number, stop. Otherwise, let p now equal this new number (which is the next prime), and repeat from step 3.
function e3createPrimeList (potentialPrimes) { 
  let primesList = [];
  //begin with the quit condition. We're removing nonprimes instead of marking them, so if the list is empty we're done
if (potentialPrimes.length == 0) { console.log("no potentials ", potentialPrimes.length); return primesList }
else {
  primesList.push(potentialPrimes.pop()); //No marked numbers, so first item will always be the next prime
  return e3pIncrementCount(potentialPrimes, primesList[-1]);
  };
}

//ðŸ§¶ 3. Enumerate the multiples of p by counting in increments of p from 2p to n, and mark them in the list (these will be 2p, 3p, 4p, ...; the p itself should not be marked).
function e3pIncrementCount (potentialPrimes, p) {
  let countArr = e3range.map(val => val * p); //returns a list of multiples of p
  let newpotentialPrimes = potentialPrimes.filter((val,ind,arr) => { return (countArr.includes(val) ? false : true) }); //marked in list by removing them from the list
  return e3createPrimeList(newpotentialPrimes); //pass it back to see if we're done
}


//ðŸ§¶ When the algorithm terminates, the numbers remaining not marked in the list are all the primes below n.

//ðŸ§¶ The main idea here is that every value given to p will be prime, because if it were composite it would be marked as a multiple of some other, smaller prime. Note that some of the numbers may be marked more than once (e.g., 15 will be marked both for 3 and 5).

//ðŸ§¶ As a refinement, it is sufficient to mark the numbers in step 3 starting from p2, as all the smaller multiples of p will have already been marked at that point. This means that the algorithm is allowed to terminate in step 4 when p2 is greater than n.[1]

//ðŸ§¶ Another refinement is to initially list odd numbers only, (3, 5, ..., n), and count in increments of 2p from p2 in step 3, thus marking only odd multiples of p. This actually appears in the original algorithm.[1] This can be generalized with wheel factorization, forming the initial list only from numbers coprime with the first few primes and not just from odds (i.e., numbers coprime with 2), and counting in the correspondingly adjusted increments so that only such multiples of p are generated that are coprime with those small primes, in the first place.























 //const answer3 = primeDiv3(600851475143);
 //document.getElementById("answer3").innerHTML = answer3;

 function primeDiv3(evalNum) {
  if (evalNum != commonPrimeDiv(evalNum)) {
    return updateprimeDiv3(evalNum);
  } else { return evalNum; };
};

function updateprimeDiv3 (UpdateMe){ 
    let update = commonPrimeDiv(UpdateMe);
    return primeDiv3(update);
};

function commonPrimeDiv(ele) {
     if ([ 2,3,5,7,11,17,19,23,29,31 ].includes(ele)) { console.log("already prime"); return (ele) } 
     else if (ele %  2 == 0) { return (ele /  2) } 
     else if (ele %  3 == 0) { return (ele /  3) } 
     else if (ele %  5 == 0) { return (ele /  5) } 
     else if (ele %  7 == 0) { return (ele /  7) } 
     else if (ele % 11 == 0) { return (ele / 11) } 
     else if (ele % 13 == 0) { return (ele / 13) } 
     else if (ele % 17 == 0) { return (ele / 17) } 
     else if (ele % 19 == 0) { return (ele / 19) } 
     else if (ele % 23 == 0) { return (ele / 23) } 
     else if (ele % 29 == 0) { return (ele / 29) } 
     else if (ele % 31 == 0) { return (ele / 31) } 
     else { console.log("could be prime"); return ele };
   };


//Have just realized I missed a step: gotta find the factors first!?
// const natNum13195 = natNumRange(2,13195,1);
// const prime13195 = rangetoPrime(Array(),natNum13195);
// const natNum600851475143 = natNumRange(600000000000,600851475143,2);
// const prime600851475143 = rangetoPrime(Array(),natNum600851475143);
// const answer3 = prime13195.filter((ele,ind,arr) => { return 600851475143 % ele == 0; });

// document.getElementById("answer3").innerHTML = answer3;

// function rangetoPrime(primeRange, testRange) {
//   if (testRange.length == 0) { return primeRange; }
//   else { 
//     return updaterangetoPrime(primeRange,testRange);
//   }
// };

// function updaterangetoPrime (primeRange,testRange){ 
//     primeRange.push(testRange[0]);
//     let tested = testRange.filter((ele,ind,arr) => { return ele % arr[0] != 0; });
//     return rangetoPrime(primeRange,tested);
// };

// const test = natNum29.filter((ele,ind,arr) => { return ele % arr[0] != 0; });
// document.getElementById("test").innerHTML = test;


//============================      2     ============================


const stopValue2 = 4000000;
const fib2 = fibSeq2([1,2]);
const evenFib2 = fib2.filter((val,ind,arr) => { return val % 2 == 0; });
const answer2 = evenFib2.reduce((acc,cur) => { return acc + cur; },0);

document.getElementById("answer2").innerHTML = answer2;

//Ok to use mutable var as long as it remains inside the code block (no side effects).

function fibSeq2(CurrentArray) {
  if (CurrentArray[CurrentArray.length -1] < stopValue2) {
    return updatefibSeq2(CurrentArray);
  } else { CurrentArray.pop(); return CurrentArray; };
};

function updatefibSeq2 (UpdateMe){ 
    let NewArray = UpdateMe;
    NewArray.push((UpdateMe[UpdateMe.length - 1] + UpdateMe[UpdateMe.length - 2]));
    return fibSeq2(NewArray);
};


//============================      1     ============================

const filteredRange1 = natNum1999.filter((a) => { 
  return a % 3 == 0 || a % 5 == 0;
});

//accumulator and current
const answer1 = filteredRange1.reduce((acc, cur) => {
  return acc + cur;
//readonly = false
}, 0);

document.getElementById("answer1").innerHTML = answer1;



</script>
</body>
</html>
